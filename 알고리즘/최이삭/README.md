## algorithm workspace



# 2020/05/27

[소스코드](./TileOrnament.js)

+ 정사각형의 타일을 합쳐서 나선 모양처럼 점점 큰 타일을 붙인 형태의 작품을 만들었다고 함.

  + 정사각형 한 변의 크기는 1, 1, 2, 3, 5, 8로 계속 나열 됨.

  + a<sub>n</sub> = a<sub>n-1</sub> + a<sub>n-2</sub>

  + 피보나치 수열과 같음.

    

  + 우리가 구하는 것은 N번째의 한 변의 크기가 아닌, N번째의 둘레를 구하는 것.

  + 직사각형의 둘레는 (가로+세로)*2

    

  + 따라서 N+1번째의 한 변의 크기와 N번째의 한 변의 크기를 구하면 해결됩니다.

# 2020/05/28

[소스코드](./UncompletedPlayer.js)

+ 들어오지 못한 놈 색출.

  + 동명이인일 수 있음.

  + participant를 순회하면서 Object를 이용해서 이름을 key로, value를 그 이름을 가진 사람 수로 저장

  + completion을 순회하면서 Object에서 completion의 사람 이름을 확인 후 감산.

  + value가 0이 된 key는 삭제하고 남아있는 key가 정답이 됨.


# 2020/05/29

[소스코드](./SkillTree.js)

+ 찍을 수 있는 스킬트리 찾기.

  + skill_trees에서 skill에 있는 순서에 맞게 인덱스를 부여함

  + skill_trees를 순회 시 인덱스가 0에서 부터 1씩 증가하는 꼴이 아니면 flag를 false로 설정하여 답이 아님을 알림

  + skill_trees를 순회 하면서 현재 skill_trees[i]의 값이 최대 인덱스라면 종료 후 answer 증가

# 2020/06/01

[소스코드](./BestAlbum.js)

+ 장르 당 최대 2개씩 앨범 찾기.

  + 가장 많이 재생된 장르를 기준으로 추천.

  + 장르 중 가장 많이 상위 재생된 곡 2개 인덱스.

# 2020/06/02

[소스코드](./ClawMachineGame.js)

+ board에서 열 별로 처음으로 인형이 존재하는 인덱스를 저장.

+ moves를 순회하면서 위에서 만들어진 인덱스를 참조하여 인형을 꺼냄.

+ 인형을 꺼냈다면 인덱스를 증가.

+ 현 인형과 이전 인형이 같다면 pop() 2회와 정답 2증가

# 2020/06/03

[소스코드](./Origami.js)

+ 규칙을 찾아보니 이전 배열에서 0을 추가하고 이전 배열의 mid를 1로 설정해서 추가하면 풀리는 문제였음.
