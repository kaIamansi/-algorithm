## algorithm workspace



### 2020.05.27 알고리즘

기강이의 풀이 :

1. 피보나치로 배열을 채웠다.
2. 직사각형의 둘레를 구하기 위해 (맨 뒤 인덱스 * 4) + ((맨 뒤-1 인덱스) * 2) 를 리턴해줬다.

오늘의 난관

1. 효율성에서 0점을 맞았다. (효율성 만점 33.3점)

```
//첫 코드
public long solution(int N) {
        int[] arr = new int[N];
        int a = 1, b = 1, c = 0;

        arr[0] = 1;
        arr[1] = 1;

        for(int i = 2; i < N; i++) {	//피보나치
	        c = a + b;
	        arr[i] = c;
	        a = b;
	        b = c;
        }
		...
```

​	이를 해결하기 위해 필요없는 변수를 없애고, for문의 내부 코드를 바꿨다.

```java
	for(int i = 2; i < N; i++) {	//피보나치
	        arr[i] = arr[i-1] + arr[i-2];
        }
```





### 2020.05.26 알고리즘

기강이의 풀이 :

1. 문자열 크기와 그 크기를 2로 나눴다.
2. 나눈 크기가 홀수인 경우와 짝수인 경우를 나눴다.





### 2020.05.25 알고리즘

기강이의 풀이 : 문자열 크기의 배열 만들고 char로 하나씩 넣어서 P와 Y의 갯수를 비교했다.

1차 수정
- 문자열에 .toLowerCase 사용해서 비교하는 코드를 줄였다.
