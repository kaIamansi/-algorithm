## algorithm workspace

# 2020/06/01

[소스코드(Kotlin)](./bestAlbum/src/BestAlbum.kt)

+ 장르와 각 노래의 재생 횟수가 주어지면, 가장 재생횟수가 높은 장르부터, 그 안에서 가장 재생횟수가 높은 노래 2곡을 뽑아 반환하는 문제.

### 풀이

1. 장르 이름, 장르 총 재생횟수, 각 노래의 재생횟수와 인덱스를 저장한다. => Map<String, Pair<Int, TreeSet<Pair<Int, Int>>>>. { 장르 이름, ( 장르 총 재생횟수, [ ( 노래의 재생횟수, 인덱스 ) ] ) }
2. TreeSet 정렬 방식을 정의한다. 노래 재생횟수 오름차순, 같다면 인덱스 내림차순.
3. 장르 총 재생횟수를 정렬해 가장 재생횟수가 많은 장르부터, 노래의 인덱스를 최대 2개씩 꺼낸다.

# 2020/05/29

[소스코드(Kotlin)](./skillTree/src/SkillTree.kt)

[소스코드(Java)](./skillTree/src/SkillTree.java)

+ 선행 스킬 순서 skill 순서를 준수한 스킬트리의 수를 반환하는 문제.
+ 모든 스킬과 스킬트리는 각각 대문자 알파벳 한 글자로 주어짐.

### 풀이

1. 대문자 알파벳 A의 아스키코드(65)를 뺀 후, 26개 크기의 배열에 스킬 순서를 저장.
2. 각 스킬트리를 순서대로 검색해 선행 스킬에 맞게 스킬트리를 짰는지 확인.

# 2020/05/28

[소스코드(Map)](./uncompletedPlayer/src/UncompletedPlayerMap.java)

[소스코드(정렬)](./uncompletedPlayer/src/UncompletedPlayerSort.java)

+ 참여 선수, 완주한 선수(참여 선수 수 - 1)가 주어지면, 완주하지 못한 선수 (1명)을 반환하는 문제.

### 풀이 1(Map)

1. 완주한 선수들의 컬렉션(Map)을 만들어 인원을 카운팅함.
2. 완주한 선수들의 이름을 뽑아내 완주하지 못한 선수를 찾아냄.

### 풀이 2(정렬)

1. 완주한 선수, 참여 선수를 정렬함.
2. 반복문을 돌려 값이 다른 경우에 함수를 반환시킴.

# 2020/05/27

[소스코드](./TileOrnament/src/TileOrnament.java)

+ 나선형으로 정사각형을 하나씩 이어 붙여 N번째 정사각형을 붙였을 때, 둘레를 구하는 문제.

1. 점화식을 도출한다. N번째 정사각형의 변의 길이 = N-1번째 정사각형의 변의 길이 + N-2번째 정사각형의 변의 길이. => N번째 정사각형의 한 변의 길이를 R(N)이라고 하면, R(N) = R(N-1) + R(N-2) 라는 점화식을 세울 수 있다. => **피보나치 수열과 점화식이 같음**
2. 각 정사각형의 변의 길이를 저장할 배열을 사용한다. (소스코드에서는 dp 배열 사용.)
3. 반복문을 통해 N번째까지 반복문을 돌린다.
4. N번째 정사각형의 변의 길이 \* 2 + N-1번째 정사각형의 변의 길이 \* 2가 답이 된다.

# 2020/05/26

[소스코드(Java)](./GetMidCharacter/src/GetMidCharacter.java)

[소스코드(Kotlin)](./GetMidCharacter/src/getMidCharacter.kt)

+ 문자열이 주어지면, 중간의 글자를 반환하기(글자수가 짝수면 가운데 두 글자.)

1. (length-1)/2 글자수를 뽑아냄.
2. 짝수라면 그 다음 글자를 뽑아냄.



# 2020/05/25

[소스코드](./pAndYCounter/src/PAndYCounter.java)

+ 문제 : 문자열이 주어지면 p,y(대소문자 구분 x)의 개수를 세어 같으면 true, 다르면 false 반환하기.

1. 문자열을 소문자로 바꾼다.(대문자도 상관없음.)
2. 알파벳 p, y의 개수를 센다.
3. 같으면 true 반환한다.
