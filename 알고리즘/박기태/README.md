## algorithm workspace

# 2020/05/27

[소스코드(Javascript)](./tileOrnament/tileOrnament.js)

- 문제 : 정사각형의 타일을 달팽이 모양(나선형)으로 한변이 1인 타일부터 N개를 점점 큰 타일을 이어 붙이고 N개를 이어붙였을 때, 가장 큰 둘레 길이를 구해라.
  <br>
- 설명 : 귀납법으로 다음에 올 타일의 한변의 길이는 피보나치 수열을 따르는 것을 확인할 수 있고, 이를 토대로 둘레의 길이를 구할 수 있다.

  1.  [1, (여기부터 시작) 1, 2, 3, 5, 8, 13, 21, …]
  2.  다음 정사각형의 한변의 길이를 구하는 피보나치 수열의 점화식을 세운다.
      > `Fibo(0) = 0, Fibo(1) = 1, Fibo(n+2) = Fibo(n+1) + Fibo(n)`
  3.  직사각형의 둘레의 길이는 가로\*세로\*2이고
      - 긴 변의 길이는 _가장 큰 정사각형 한 변의 길이+두번째로 큰 정사각형 한 변의 길이_
      - 짧은 변의 길이는 _가장 큰 정사각형 한 변의 길이_ 다. 이를 토대로 점화식을 세운다.
  4.  `F(n) = ((Fibo(n) + Fibo(n-1)) + Fibo(n))\*2`
      - `Fibo(n) + Fibo(n-1) = Fibo(n+1)`로 정리하면
      - F(n) = _2(Fibo(n)+Fibo(n+1))_ 또는 _2(Fibo(n+2))_

    <br>

- 풀이 : _(`2(Fibo(n)+Fibo(n+1))`의 경우)_

  1. 1부터 시작하는(N은 최소 1이기 때문에) 피보나치 수열(이전값: 1, 현재값: 1)을 N-1차 만큼 반복한다.
  2. 현재값을 임시변수(temp)에 저장한다.
  3. 이전값과 현재값을 더한 겂을 현재값에 저장한다.
  4. 이전값에 임시변수에 저장된 값을 대입한다.
  5. 반복문 탈출하고 2\*(이전값+현재값)을 반환한다.

  <br>

- 개선책 : temp 변수 대신 배열을 이용하여 `[이전값, 현재값]` 을 지정하고 다음 index에 `이전값+현재값`을 추가하고 Left Shift를 수행하는 것을 반복한다. 즉, `풀이 2, 3, 4`의 과정을 배열과 shift()로 대신하여 성능을 최적화한다.

# 2020/05/26

[소스코드(Java)](./GetMidCharacter/src/GetMidCharacter.java)

[소스코드(Kotlin)](./GetMidCharacter/src/getMidCharacter.kt)

- 문자열이 주어지면, 중간의 글자를 반환하기(글자수가 짝수면 가운데 두 글자.)

1. (length-1)/2 글자수를 뽑아냄.
2. 짝수라면 그 다음 글자를 뽑아냄.

# 2020/05/25

[소스코드](./pAndYCounter/src/PAndYCounter.java)

- 문제 : 문자열이 주어지면 p,y(대소문자 구분 x)의 개수를 세어 같으면 true, 다르면 false 반환하기.

1. 문자열을 소문자로 바꾼다.(대문자도 상관없음.)
2. 알파벳 p, y의 개수를 센다.
3. 같으면 true 반환한다.
